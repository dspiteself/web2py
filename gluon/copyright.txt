------------------------------ main.py --------------------------------

def serve_static_file(filename):
    data=open(filename,'rb').read()
    length=len(data)
    headers={}
    headers['Content-Type']=contenttype(filename)
    raise HTTP(200,data,**headers)

def serve_controller(request,response,session):    
    ###################################################
    # build evnironment for controller and view
    ###################################################
    environment={}
    for key in html.__all__: environment[key]=eval('html.%s' % key)      
    for key in validators.__all__: environment[key]=eval('validators.%s' % key)
    environment['T']=translator(request)	
    environment['HTTP']=HTTP
    environment['redirect']=redirect
    environment['request']=request
    environment['response']=response
    environment['session']=session
    environment['SQLDB']=SQLDB
    environment['SQLField']=SQLField
    environment['SQLFORM']=SQLFORM
    environment['SQLTABLE']=SQLTABLE
    # set default view, controller can override it
    response.view='%s/%s.html' % (request.controller,request.function)
    # also, make sure the flash is passed through
    if session.flash: response.flash, session.flash=session.flash, None  
    ###################################################
    # process models, controller and view (if required)
    ###################################################     
    run_models_in(environment)  
    view_environment=copy.copy(environment)  
    run_controller_in(request.controller,request.function,environment)
    if response.body==None: 
	for key,value in response._vars.items(): view_environment[key]=value
        run_view_in(view_environment)
    raise HTTP(200,response.body,**response.headers)
    
def wsgibase(environ, responder):    
    request=Request()
    response=Response()
    session=Session()
    session_id=None
    try:
	current_path=os.getcwd()	
	###################################################
	# parse the environment variables - DONE
	###################################################
	for key, value in environ.items():
	    request.env[key.lower().replace('.','_')]=value
	###################################################
	# valudate the path in url
	###################################################
	path=request.env.path_info[1:]
	if not regex_url.match(path): 
            raise HTTP(400,error_message)
	items=path.split('/')
	###################################################
	# serve if a static file
	###################################################
	if len(items)>2 and items[1]=='static':
	    static_file='applications/%s/static/%s' % \
		(items[0],'/'.join(items[2:]))	    
	    if not os.access(static_file,os.R_OK): 
		raise HTTP(400,error_message)
	    serve_static_file(static_file)
	###################################################
	# parse application, controller and function
	###################################################
	if len(items) and items[-1]=='': del items[-1]	
	if len(items)==1: redirect('/%s/default/index' % items[0])
	if len(items)==2: redirect('/%s/%s/index' % tuple(items[:2]))	
	if len(items)>3: items,request.args=items[:3],items[3:]
	if request.args==None: request.args=[]
	request.application=items[0]
	request.controller=items[1]
	request.function=items[2]
        ###################################################
	# get the GET and POST data -DONE
	###################################################
	try: 
	     body=request.env.wsgi_input.read(int(request.env.content_length))
	except Exception,e:
	     body='' 
        if request.env.request_method in ['POST', 'BOTH']:           
   	    dpost=cgi.FieldStorage(fp=cStringIO.StringIO(body),
		  	           environ=environ,keep_blank_values=1)        
	    for key in dpost.keys(): 
                dpk=dpost[key]
	        if type(dpk)==types.ListType:
		   request.post_vars[key]=request.vars[key]=[x.value for x in dpk]	
	        elif not dpk.file or type(dpk.file)==type(cStringIO.StringIO()):
		   request.post_vars[key]=request.vars[key]=dpk.value
   	        else:
		   request.post_vars[key]=request.vars[key]=dpk	
	if request.env.request_method in ['GET', 'BOTH']:
  	    dget=cgi.FieldStorage(environ=environ,keep_blank_values=1)
            for key in dget.keys():
	       request.get_vars[key]=request.vars[key]=dget[key].value	
	application_path='applications/%s/' % request.application
        controller_path='controllers/%s.py' % request.controller        
	###################################################
	# access the requested application
	###################################################	
	try: os.chdir(application_path)
	except: raise HTTP(400,error_message)
	###################################################
	# load cookies
	###################################################
	cookie = Cookie.SimpleCookie()
	if request.env.http_cookie: cookie.load(request.env.http_cookie)
	request.cookies=Storage(cookie)	
	###################################################
	# load session
	###################################################
	try:
	    session_id=cookie['session_id'].value	    
	    session=load_storage('sessions/'+session_id)
	except:
	    session_id=request.env.remote_addr+'.'+str(random())[2:]
	response.cookies['session_id']=session_id
	###################################################
	# run controller
	###################################################
	if not items[1]=='static':
	    serve_controller(request,response,session)	
    except HTTP, http_response:
        ###################################################
	# on sucess, committ database
	###################################################	
	SQLDB.close_all_instances(SQLDB.commit)
	###################################################
	# save cookies is session (static files do not have a session)
	###################################################
	if session_id:
  	    cookie=Cookie.SimpleCookie()
	    for key,value in response.cookies.items(): cookie[key]=value
            cookie['session_id']['path']='/%s' % request.application 
	    http_response.headers.append(('Set-Cookie',str(cookie)[11:]))
            save_storage(session,'sessions/'+session_id)
	###################################################   
	# whatever happens return the intended HTTP response
	###################################################	
	os.chdir(current_path)	
	return http_response.to(responder)
    except RestrictedError, e:
        ###################################################
	# on application error, rollback database
	###################################################	
	SQLDB.close_all_instances(SQLDB.rollback)
        ticket=e.log(request)
        os.chdir(current_path)
	return HTTP(400,error_message_ticket % ticket).to(responder)
        #return HTTP(400,error_message).to(responder)
    except Exception, exception:
        ###################################################
	# on application error, rollback database
	###################################################	
	SQLDB.close_all_instances(SQLDB.rollback)
	###################################################   
	# whatever happened log error and return HTTP response
	###################################################  
	e=RestrictedError('Framework','','',locals())
	if os.getcwd()!=current_path: ticket=e.log(request)
	else: ticket='None'
	os.chdir(current_path)
        print e.traceback
	return HTTP(400,error_message_ticket % ticket).to(responder)

------------------------------ http --------------------------------

class HTTP:
    def __init__(self,status,body='',**headers):
        if status==200: self.status='200 OK'
        elif status==301: self.status='301 MOVED PERMANENTLY'
        elif status==307: self.status='307 TEMPORARY REDIRECT'
        elif status==400: self.status='400 BAD REQUEST'
        else: self.status=str(status)+' '
        self.body=body
        if not headers.has_key('Content-Type'):
              headers['Content-Type']='text/html'
        headers['Content-Length']=str(len(body))
        self.headers=headers.items()
    def to(self,responder):
        responder(self.status,self.headers)
        return [self.body]

def redirect(location): raise HTTP(307,'',Location=location)
        
------------------------------ restricted --------------------------------

class RestrictedError:
    def __init__(self,layer='',code='',output='',environment={}):
	self.layer=layer
	self.code=code
	self.output=output
	self.traceback=traceback.format_exc()
	self.environment=environment
    def html(self):
	return """
	<br/><textarea cols="80" rows="10" name="code" class="python">%s</textarea>
	<br/><p>Here is the code for %s</p>
	<textarea cols="80" rows="10" name="code" class="python">%s</textarea><br/>
	<p>Before crash it produced the following output:</p>
	<textarea cols="80" rows="10" name="code" class="python">%s</textarea>""" % \
	(self.traceback,self.layer,self.code,self.output)

    def log(self,request):
	a=request.application
	d={'layer':str(self.layer),
	   'code':str(self.code),
	   'output':str(self.output),
	   'traceback':str(self.traceback)}
	print self.traceback
	f=request.env.remote_addr+'.'+str(random())[2:]
	cPickle.dump(d,open('errors/'+f,'wb'))
	return '<a href="/admin/default/ticket/%s/%s" target="_blank">%s/%s</a>' % (a,f,a,f)
    def load(self,file):
	d=cPickle.load(open(file,'rb'))
	self.layer=d['layer']
	self.code=d['code']
	self.output=d['output']
	self.traceback=d['traceback']

def restricted(code,environment={},layer='Unkown'):
    stdout=sys.stdout
    sys.stdout=cStringIO.StringIO()
    try: 
        exec ccode in environment
    except Exception, exception:
	output=sys.stdout.getvalue()
	sys.stdout=stdout
	raise RestrictedError(layer,code,output,environment)
    output=sys.stdout.getvalue()
    sys.stdout=stdout
    return output

------------------------------ html --------------------------------

def URL(a=None,c=None,f=None,r=None):
    application=controller=function=None
    if r:
        application=r.application
        controller=r.controller
        function=r.function    
    if a: application=a    
    if c: controller=c
    if f: function=f    
    if not (application and controller and function):
	raise SyntaxError, 'not enough information to build the url'
    return '/%s/%s/%s' % (application, controller, function)        

ON=None

class XML:
    def __init__(self,text):
        self.text=text
    def xml(self):
        return self.text

class DIV:
    tag='div'
    def __init__(self,*components,**attributes):        
        if self.tag[-1]=='/' and components:
	    raise SyntaxError, '<%s> tags cannot have components' % self.tag
	self.components=list(components)
	self.attributes=attributes
	self.postprocessing()
	self.errors=Storage()
	self.vars=Storage()
	self.session=None
    def postprocessing(self):
	return
    def rec_clear(self):	
	for c in self.components:
	    try: 
		c.errors,c.vars=self.errors,self.vars
		if self.session: c.session=self.session
		c.rec_clear()
            except: pass
    def accepts(self,vars,session=None):	
        self.errors=Storage()
	self.vars=Storage()
	self.session=session
        self.rec_clear()
        if session!=None and not(vars.has_key('_form_key') and \
                                 session.has_key('_form_key') and \
     	                         vars['_form_key']==session['_form_key']):
            return False
        self.rec_accepts(vars)	
        return len(self.errors)==0
    def rec_accepts(self,vars):
	for c in self.components:
	    try: c.rec_accepts(vars)
	    except: pass	
    def _xml(self):
        items=self.attributes.items()
        fa=' '.join([key[1:].lower() for key,value in items if key[:1]=='_' and value==None]+['%s="%s"' % (key[1:].lower(),str(value).replace('"',"'")) for key,value in self.attributes.items() if key[:1]=='_' and value])
	if fa: fa=' '+fa
        co=''
        for component in self.components:
	    try: co+=component.xml()
            except: co+=cgi.escape(str(component))
	return fa,co
    def xml(self):
	fa,co=self._xml()
        if self.tag[-1]=='/': return '<%s%s/>' % (self.tag[:-1],fa)
        return '<%s%s>%s</%s>' % (self.tag,fa,co,self.tag)

class HTML(DIV):
    tag='html'
    def xml(self):
        fa,co=self._xml()
        return '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">\n<%s%s>%s</%s>' % (self.tag,fa,co,self.tag)

class HEAD(DIV): tag='head'

class TITLE(DIV): tag='title'

class META(DIV): tag='meta'

class LINK(DIV): tag='link/'

class SCRIPT(DIV):
    tag='script'
    def xml(self):
	fa,co=self._xml()
        if co: return '<%s%s><!--\n%s\n//--></%s>' % (self.tag,fa,co,self.tag)
        else: return DIV.xml(self)

class STYLE(SCRIPT): tag='style'

class SPAN(DIV): tag='span'

class BODY(DIV): tag='body'

class H1(DIV): tag='h1'

class H2(DIV): tag='h2'

class H3(DIV): tag='h3'

class H4(DIV): tag='h4'

class H5(DIV): tag='h5'

class H6(DIV): tag='h6'

class P(DIV): tag='p'

class B(DIV): tag='B'

class BR(DIV): tag='br/'

class HR(DIV): tag='hr/'

class A(DIV): tag='a'

class EM(DIV): tag='em'

class EMBED(DIV): tag='embed/'

class TT(DIV): tag='tt'

class PRE(DIV): tag='pre'

class CENTER(DIV): tag='big'

class LI(DIV): tag='li'

class LU(DIV): 
    tag='lu'
    def postprocessing(self):	
	components=[]
	for c in self.components:
	    if type(c)==types.InstanceType and c.__class__==LI:
		components.append(c)
	    else:
		components.append(LI(c))
        self.components=components

class LO(LU):  tag='lo'

class TD(DIV): tag='td'

class TH(DIV): tag='th'

class TR(DIV):
    tag='tr'
    def postprocessing(self):
        components=[]
        for c in self.components:
            if type(c)==types.InstanceType and c.__class__ in [TD, TH]:
                components.append(c)
            else:
                components.append(TD(c))
        self.components=components

class TABLE(DIV): 
    tag='table'
    def postprocessing(self):
        components=[]
        for c in self.components:
            if type(c)==types.InstanceType and c.__class__==TR:
                components.append(c)
            else:
                components.append(TR(*c))
        self.components=components

class TEXTAREA(INPUT): 
    tag='textarea'
    def postprocessing(self):
	if not self.attributes.has_key('_rows'): 
	    self.attributes['_rows']=10
	if not self.attributes.has_key('_cols'):
	    self.attributes['_cols']=40
        if self.attributes.has_key('value') and self.attributes['value']!=None:
            self.components=[self.attributes['value']]

class OPTION(DIV): tag='option'

class SELECT(INPUT): 
    tag='select'
    def postprocessing(self):
	components=[]
	for c in self.components:
	    if type(c)==types.InstanceType and c.__class__==OPTION:
		components.append(c)
	    else:
		components.append(OPTION(c,_value=str(c)))
            if self.attributes.has_key('value') and \
               self.attributes['value']!=None and \
               self.attributes['value']==components[-1].attributes['_value']:
                components[-1].attributes['_selected']=ON
        self.components=components

class FORM(DIV): 
    tag='form'
    def postprocessing(self):
        if not self.attributes.has_key('_action'): self.attributes['_action']=""
        if not self.attributes.has_key('_method'): self.attributes['_method']="post"
        if not self.attributes.has_key('_enctype'): self.attributes['_enctype']="mime/multipart"
    def xml(self):        
        if self.session!=None:
	   try:
	       if self.components[-1].attributes['_name']=='_form_key':
		   self.components=self.components[:-1]
	   except: pass
           key=self.session['_form_key']=str(random.random())[2:]
           self.components.append(INPUT(_type='hidden',
                                  _name='_form_key',_value=key))
        return DIV.xml(self)

class BEAUTIFY(DIV):
    tag='div'
    def postprocessing(self):
        components=[]
	attributes=copy.copy(self.attributes)
	if attributes.has_key('_class'): attributes['_class']+='i'
        for c in self.components:
	    t=type(c)
	    s=dir(c) # this really has to be fixed!!!!
            if 'xml' in s: # assume c has a .xml()
                components.append(c)
	        continue
            if 'keys' in s:
                rows=[]
		try: 
		    keys=c.keys()
		    keys.sort()
	            for key in keys:
	 	        if str(key)[:1]=='_': continue
                        value=c[key]
		        if type(value)==types.LambdaType: continue 
	                rows.append(TR(TD(B(BEAUTIFY(key,**attributes))),
			    	       TD(':'),
	           		       TD(BEAUTIFY(value,**attributes))))
                    components.append(TABLE(*rows,**attributes))
		    continue
		except: pass
	    if t==types.ClassType: continue
	    if '__iter__' in s and not 'close' in s:
                items=[TR(TD(BEAUTIFY(item,**attributes))) for item in c]
 	    	components.append(TABLE(*items,**attributes))
		continue
            components+=cgi.escape(str(c))

        self.components=components

------------------------------ validators.py --------------------------------

class IS_MATCH:
    def __init__(self,expression,error_message='invalid!'):
        self.regex=re.compile(expression)
        self.error_message=error_message
    def __call__(self,value):
        match=self.regex.match(value)	
        if match: return (match.group(),None)
	return (value,self.error_message)

class IS_EXPR:
    def __init__(self,expression,error_message='invalid!'):
        self.expression=expression
	self.error_message=error_message
    def __call__(self,value):
	environment={'value':value}
        exec('__ret__='+self.expression) in environment
	if environment['__ret__']: return (value,None)
        return (value,self.error_message)

class IS_IN_SET:
    def __init__(self,theset,error_message='invalid!'):
        self.theset=theset
        self.error_message=error_message
    def __call__(self,value):
        if value in self.theset: return (value,None)
        return (value,self.error_message)

class IS_INT_IN_RANGE:
    def __init__(self,minimum,maximum,error_message='invalid!'):
        self.minimum=minimum
	self.maximum=maximum
        self.error_message=error_message
    def __call__(self,value):
        fvalue=float(value)
	value=int(value)
        if value==fvalue and self.minimum<=value<self.maximum: 
            return (value,None)
        return (value,self.error_message)

class IS_FLOAT_IN_RANGE:
    def __init__(self,minimum,maximum,error_message='invalid!'):
        self.minimum=minimum
	self.maximum=maximum
        self.error_message=error_message
    def __call__(self,value):	
	value=float(value)
        if self.minimum<=value<self.maximum: return (value,None)
        return (value,self.error_message)

class IS_NOT_EMPTY(IS_MATCH):
    def __init__(self,error_message='cannot be empty!'):
	IS_MATCH.__init__(self,'.+',error_message)

class IS_ALPHANUMERIC(IS_MATCH):
    def __init__(self,error_message='must be alphanumeric!'):
	IS_MATCH.__init__(self,'^[\w]*$',error_message)

class IS_EMAIL(IS_MATCH):
    def __init__(self,error_message='invalid email!'):
	IS_MATCH.__init__(self,'^\w+(.\w+)*@(\w+.)+(\w+)$',error_message)

class IS_URL(IS_MATCH):
    def __init__(self,error_message='invalid url!'):
	IS_MATCH.__init__(self,'^http\://(\w+.)*(\w+)$',error_message)

class IS_TIME:
    def __init__(self,error_message='requires valid HH:MM:SS!'):
	self.error_message=error_message
    def __call__(self,value):
	try:
	    ivalue=value
	    value=re.compile('((?P<h>[0-9]+))([^0-9 ]+(?P<m>[0-9 ]+))?([^0-9ap ]+(?P<s>[0-9]*))?((?P<d>[ap]m))?').match(value.lower())
	    h,m,s=int(value.group('h')),0,0
	    if value.group('m')!=None: m=int(value.group('m'))
	    if value.group('s')!=None: s=int(value.group('s'))
	    if value.group('d')=='pm' and 0<h<12: h=h+12
	    if not (h in range(24) and m in range(60) and s in range(60)):
		raise Exception
	    value='%.2i:%.2i:%.2i' % (h,m,s)
	    return (value,None)
	except:
	    return (ivalue,self.error_message)

class IS_DATE:
    def __init__(self,error_message='requires valid YYYY-MM-DD!'):
	self.error_message=error_message
    def __call__(self,value):
	import datetime
	try:
	    ivalue=value
	    value=re.compile('((?P<y>[0-9]+))([^0-9 ]+(?P<m>[0-9]+))([^0-9 ]+(?P<d>[0-9]+))').match(value.lower())
	    y,m,d=int(value.group('y')),int(value.group('m')),int(value.group('d'))
	    datetime.date(y,m,d)
	    value='%.4i-%.2i-%.2i' % (y,m,d)
	    return (value,None)
	except:
	    return (ivalue,self.error_message)

class IS_DATETIME:
    def __init__(self,error_message='requires valid YYYY-MM-SS HH:MM:SS!'):
	self.error_message=error_message
    def __call__(self,value):
	ivalue=value
	try:
	    date,time=value.split()
	    d,e=IS_DATE()(date)
	    if e: raise Exception
	    t,e=IS_TIME()(time)
	    if e: raise Exception
	    return (d+' '+t,None)
	except:
	    return (ivalue,self.error_message)



------------------------------ sql.py --------------------------------

DATA_TYPES={'sqlite':{'boolean':'CHAR(1)',
	    	      'string':'CHAR(n)',
	    	      'password':'CHAR(n)',
		      'blob':'BLOB',
		      'upload':'CHAR(64)',
	  	      'integer':'INTEGER',
	    	      'double':'DOUBLE',
		      'date':'DATE',
	              'time':'TIME',	
	              'datetime':'TIMESTAMP',
		      'id':'INTEGER PRIMARY KEY AUTOINCREMENT',
		      'reference':'field_name REFERENCES foreign_key'},
	    'mysql':{'boolean':'CHAR(1)',
	    	      'string':'CHAR(n)',
	    	      'password':'CHAR(n)',
		      'blob':'BLOB',
		      'upload':'CHAR(64)',
	  	      'integer':'INT',
	    	      'double':'DOUBLE',
		      'date':'DATE',
	              'time':'TIME',	
	              'datetime':'TIMESTAMP',
		      'id':'INT AUTO_INCREMENT NOT NULL',
		      'reference':'FOREIGN KEY field_name REFERENCES foreign_key'},
	    'postgres':{'boolean':'CHAR(1)',
	    	      'string':'CHAR(n)',
	    	      'password':'CHAR(n)',
		      'blob':'BYTEA',
		      'upload':'CHAR(64)',
	  	      'integer':'INTEGER',
	    	      'double':'FLOAT8',
		      'date':'DATE',
	              'time':'TIME',	
	              'datetime':'TIMESTAMP',
		      'id':'SERIAL PRIMARY KEY',
		      'reference':'field_name INTEGER REFERENCES foreign_key'}}

def sql_represent(object):    
    return "'%s'" % str(object).replace("'","''")

def cleanup(text):
    return re.sub('\W+','_',text.lower())

class SQLDB(SQLStorage):
    _instances={}
    @static_method
    def close_all_instances(action): 
	try: 
            instances=SQLDB._instances[os.getpid()]
            while instances: 
                instance=instances.pop()
                action(instance)
                instance._connection.close()
	except: return
    def __init__(self,uri='sqlite://dummy.db'):
	self._uri=uri
	pid=os.getpid()
	if self._instances.has_key(pid): self._instances[pid].append(self)
	else: self._instances[pid]=[self]
	if self._uri[:9]=='sqlite://': 
	    self._dbname='sqlite'
	    self._connection=sqlite3.Connection(uri[9:])	
            self._cursor=self._connection.cursor()
	    pid=os.getpid()
	elif self._uri[:8]=='mysql://':
	    self._dbname='mysql'
	    m=re.compile('^((?P<user>[^:@]+)(:(?P<passwd>[^@]+))@)?(?P<host>[^@/]+)/(?P<db>.+)$').match(self._uri[8:])
	    self._connection=MySQLdb.Connection(db=m.group('db'),
						user=m.group('user'),
						passwd=m.group('passwd'),
						host=m.group('host'))
            self._cursor=self._connection.cursor()
	elif self._uri[:11]=='postgres://': 
	    self._dbname='postgres'
	    m=re.compile('^(?P<user>[^:@]+)(\:(?P<passwd>[^@]*))?@(?P<host>[^\:/]+)(\:(?P<port>[0-9]+))?/(?P<db>.+)$').match(self._uri[11:])
	    user=m.group('user')
            if not user: raise SyntaxError, "User required"
	    passwd=m.group('passwd')
            if not passwd: passwd=''
	    host=m.group('host')
            if not host: raise SyntaxError, "Host name required"
	    db=m.group('db')
            if not db: raise SyntaxError, "Database name required"
	    port=m.group('port')
	    if not port: port='5432'
	    self._connection=psycopg2.connect("dbname='%s' user='%s' host='%s' port=%s password='%s'" % (db,user,host,port,passwd))
            self._cursor=self._connection.cursor()
            self._cursor.execute('BEGIN;')
	else:
	    raise SyntaxError, 'database type not supported'
	pass
    def define_table(self,tablename,*fields):
	tablename=cleanup(tablename)
	if tablename in dir(self) or tablename[0]=='_':
	    raise SyntaxError, 'invalid table name'
	t=self[tablename]=SQLTable(tablename,*fields)	
	t._create_query=t._create() ### need to do this here to make references
	return t
    def tables(self):
	return [key for key in self.keys() if key[0]!='_']
    def __call__(self,where=''):
	return SQLSet(self,where)
    def commit(self):
	self._connection.commit()
	#self._connection.close()
    def rollback(self):
	self._connection.rollback()
	#self._connection.close()

class SQLALL:
    def __init__(self,table): self.table=table
    def __str__(self): return ', '.join([self.table._tablename+'.%s' % name for name in self.table.fields])	    

class SQLTable(SQLStorage):
    def __init__(self,tablename,*fields):
	self._tablename=tablename
	self.fields=[]
	self._referenced_by=[]
	fields=list(fields)
	fields.insert(0,SQLField('id','id'))
	for field in fields:
	    self.fields.append(field.name)
	    self[field.name]=field
	    field._tablename=self._tablename
	self.ALL=SQLALL(self)	
	self._create_query=None
    def __str__(self):
	return self._create_query
    def _create(self):
	fields=[]
	translator=DATA_TYPES[self._db._dbname]
	for k in self.fields:
	    field=self[k]
	    if field.type[:9]=='reference':
		referenced=field.type[10:].strip()
		if not referenced:
		    raise SyntaxError, 'SQLTable: referemce to nothing!'
		if not self._db.has_key(referenced):
		    raise SyntaxError, 'SQLTable: table "%s" does not exist' % referenced
		referee=self._db[referenced]
		line=translator[field.type[:9]].replace('field_name',field.name).replace('foreign_key',referenced+'(id)')
		if self._tablename in referee.fields:
		    raise SyntaxError, 'SQLField: table "%s" has already a field called "%s"' % self._tablename
		fields.append(line)
            elif not translator.has_key(field.type):
		raise SyntaxError, 'SQLField: "%s" is an unkown field type' % field.type
	    else:						      
  	        type=translator[field.type].replace('(n)','(%s)' % field.length)
		fields.append('%s %s' % (field.name,type))
	fields=',\n\t'.join(fields)
	other='' ## innoDB
	query='CREATE TABLE %s(\n\t%s\n)%s;' % (self._tablename,fields,other)
	return query
    def create(self):
	self._db._cursor.execute(str(self))        
    def _drop(self):
	return 'DROP TABLE %s;' % self._tablename
    def drop(self):
	self._db._cursor.execute(self._drop())
	del self._db[self._tablename]
    def _insert(self,**fields):
	fs,vs=[],[]
	for fieldname in self.fields:
	    if fieldname=='id': continue
	    field=self[fieldname]
	    if fields.has_key(fieldname):
		fs.append(fieldname)
		value=fields[fieldname]
		try: vs.append(sql_represent(value.id))
		except: vs.append(sql_represent(value))
	    else:
	        if field.default==None: 
		    raise SyntaxError, 'no default value for field'
		fs.append(fieldname)
		vs.append(sql_represent(field.default))		    
	sql_f=', '.join(fs)
	sql_v=', '.join(vs)
	sql_t=self._tablename
	return 'INSERT INTO %s(%s) VALUES (%s);' % (sql_t,sql_f,sql_v)
    def insert(self,**fields):
	self._db._cursor.execute(self._insert(**fields))
	return self._db._cursor.lastrowid

class SQLXorable:
    def __init__(self,name): self.name=name
    def __or__(self,other): return SQLXorable(str(self)+', '+str(other))
    def __str__(self): return self.name

class SQLField(SQLXorable):
    def __init__(self,fieldname,type='string',
		 length=32,default=None,requires=[]):
	self.name=cleanup(fieldname)
	if fieldname in dir(SQLTable) or fieldname[0]=='_':
	    raise SyntaxError, 'invalid field name'			 
	try: self.type='reference '+type._tablename
	except: self.type=type             # 'string', 'integer'
	self.length=length                 # 'string', 'integer'
	self.default=default               # None if required
	self.requires=requires
    def __eq__(self,value): return SQLQuery(self,'==',value)
    def __ne__(self,value): return SQLQuery(self,'!=',value)
    def __lt__(self,value): return SQLQuery(self,'<',value)
    def __lg__(self,value): return SQLQuery(self,'<=',value)
    def __gt__(self,value): return SQLQuery(self,'>',value)
    def __ge__(self,value): return SQLQuery(self,'>=',value)
    def __str__(self): return '%s.%s' % (self._tablename,self.name)
    def __invert__(self): return SQLXorable(str(self)+' DESC')

class SQLQuery:
    def __init__(self,left,op=None,right=None):
	self.left,self.op,self.right=left,op,right
    def __and__(self,other): return SQLQuery(self,'&',other)
    def __or__(self,other): return SQLQuery(self,'|',other)
    def __invert__(self): return SQLQuery(None,'~',self)
    def __str__(self):
	if self.op==None and self.right==None: return self.left
	if self.op=='~': return 'NOT %s' % str(self.right)
	if type(self.right)==types.InstanceType:
	    lr=(str(self.left),str(self.right))
	else: 
	    lr=(str(self.left),sql_represent(self.right))
	if self.op=='&': return '(%s AND %s)' % lr
	if self.op=='|': return '(%s OR %s)' % lr
	if self.op=='==': return '%s=%s' % lr
	if self.op=='!=': return '%s!=%s' % lr
	if self.op=='<': return '%s<%s' % lr
	if self.op=='<=': return '%s<=%s' % lr
	if self.op=='>': return '%s>%s' % lr
	if self.op=='>=': return '%s>=%s' % lr

class SQLSet:
    def __init__(self,db,where=''):
	self._tables=[]
	# find out wchich tables are involved
        self.sql_w=str(where)
	#print self._tables
    def __call__(self,where):       
    def _select(self,*fields,**attributes):
	### if not fields specified take them all from the requested tables
	if not fields: fields=[self._db[table].ALL for table in self._tables]
	sql_f=', '.join([str(f) for f in fields])
	tablenames=parse_tablenames(self.sql_w+' '+sql_f)	
	if len(tablenames)<1: raise SyntaxError, 'no tables selected'
	sql_t=', '.join(tablenames)
	self.colnames=[c.strip() for c in sql_f.split(', ')]
        if self.sql_w: sql_w=' WHERE '+self.sql_w
        else: sql_w=''
	sql_o=''
	if attributes.has_key('orderby'): 
	    sql_o=' ORDER BY '+str(attributes['orderby'])
	if attributes.has_key('groupby'): 
	    sql_o+=' GROUP BY '+str(attributes['groupby'])
	if attributes.has_key('limitby'): 
	    lmin,lmax=attributes['limitby']
	    sql_o+=' LIMIT %i OFFSET %i' % (lmax-lmin,lmin)
	return 'SELECT %s FROM %s%s%s;'%(sql_f,sql_t,sql_w,sql_o) 
    def select(self,*fields,**attributes):
	query=self._select(*fields,**attributes)       
	self._db._cursor.execute(query)
        response=self._db._cursor.fetchall()
    def _delete(self):
	if len(self._tables)!=1:
	    raise SyntaxError, 'unable to determine what to delete'
	tablename=self._tables[0]
        if self.sql_w: sql_w=' WHERE '+self.sql_w
        else: sql_w=''
	return 'DELETE FROM %s%s;' % (tablename,sql_w)
    def delete(self):
	self._db._cursor.execute(self._delete())
    def _update(self,**fields):
	sql_v='SET '+', '.join(['%s=%s' % (field,sql_represent(value)) for field,value in fields.items()])
	tablenames=self._tables
	if len(tablenames)!=1: 
            raise SyntaxError, 'unable to determine what to do'
	sql_t=tablenames[0]
        if self.sql_w: sql_w=' WHERE '+self.sql_w
        else: sql_w=''
	return 'UPDATE %s %s%s;' % (sql_t,sql_v,sql_w)
    def update(self,**fields):
        self._db._cursor.execute(self._update(**fields))

def update_record(t,s,a):
    s.update(**a)
    for key,value in a.items(): t[str(key)]=value

class SQLRows:
    def __init__(self,db,response,*colnames):
	self._db=db
	self.colnames=colnames
	self.response=response	
    def __len__(self):
	return len(self.response)
    def __getitem__(self,i):	
	if i>=len(self.response) or i<0:
	    raise SyntaxError, 'SQLRows.__getitem__: no such row'
	if len(self.response[0])!=len(self.colnames):
	    raise SyntaxError, 'SQLRows.__getitem__: internal error'
	row=SQLStorage()	
	for j in range(len(self.colnames)):
	    tablename,fieldname=self.colnames[j].split('.')
	    field=table[fieldname]
	    if not row.has_key(tablename):
		row[tablename]=SQLStorage()
	    if field.type[:9]=='reference':
		referee=field.type[10:].strip()
		rid=self.response[i][j]
		row[tablename][fieldname]=rid
		#row[tablename][fieldname]=SQLSet(self._db[referee].id==rid)
	    else:
		row[tablename][fieldname]=self.response[i][j]
	    if fieldname=='id':
		id=row[tablename].id
	        row[tablename].update_record=lambda t=row[tablename], \
                    s=self._db(table.id==id),**a: update_record(t,s,a)
		for referee_table,referee_name in table._referenced_by:
		    s=self._db[referee_table][referee_name]
		    row[tablename][referee_table]=SQLSet(self._db,s==id)
	if len(row.keys())==1: return row[row.keys()[0]]
	return row
    def __iter__(self):
	for i in range(len(self)):
	    yield self[i]


